% !TEX root = 0_main.tex
\chapter{HDL Synthesis}\label{chap:HDL_Synth}
As described in \sect{subsec:preli_GC}, Yao's protocol requires the function to be represented as a Boolean circuit.
Previous work like FairPlay \cite{malkhi2004fairplay} and WYSTERIA \cite{rastogi2014wysteria} used custom-made languages to describe a function and generate the circuit for GC operations.
In our \sys{} framework, the user may describe a function in a standard HDL like Verilog or VHDL.
She may also write the function in a high level language like C/C++ and convert it to HDL using a HLS tool.
\sys{} uses existing HDL synthesis tools to map an HDL to a list of basic binary gates.
In digital circuit theory, this list is called a \emph{netlist}.
The netlist is generated based on various constraints and objectives such that it is functionally equivalent to the HDL/HLS input function.
Exploiting synthesis tools helps to reduce both number of non-XOR gates in the circuit and the garbling time while also making the framework easily accessible.

\section{Synthesis Flow}
In the first step, a synthesis converts functional description of a circuit into a structural representation consisting of standard logical elements.
Then, it converts this structural representation into a netlist specific to the target platform.
In both steps, the synthesis tool works under a set of user defined constraints/objectives like minimizing the total delay or limiting the area.
In the following, we describe the details of these two steps and how we manipulate the synthesis tools in each of the steps to generate optimized netlists for SFE.

\subsection{Synthesis library}
The first step in the synthesis flow is to convert arithmetic and conditional operations like add, multiply, and if-else to their logical representations that fits best to the user's constraints.
For example, the sum of two N-bit numbers can be replaced with an N-bit ripple carry adder in case of area optimization or an N-bit carry look ahead adder in case of timing optimization.
A library that consists of these various implementations is called a \emph{synthesis library}.
We develop our own synthesis library that includes implementations customized for SFE.
In this library, we build the arithmetic operations based on a full adder with one non-XOR gate \cite{BP06} and conditional operations based on a 2-to-1 multiplexer (MUX) with one non-XOR gate \cite{kolesnikov2008improved}.

\subsection{Technology library}
The next step is to map the structural representation onto a \emph{technology library} to generate the netlist.
A technology library contains basic units available in the target platform.
For example, tools targeting Field Programmable Gate Arrays (FPGAs) like Xilinx ISE or Quartus contain Look-Up Tables and Flip Flops in their technology libraries, which form the architecture of an FPGA.
On the other hand, tools targeting Application Specific Integrated Circuits (ASICs) like Synopsys DC, Cadence, and ABC, may contain a more diverse collection of elements starting from basic gates like AND, OR, etc., to more complex units like FFs.
The technology library contains logical descriptions of these units along with performance parameters like their delay and area.
The goal of the synthesis tool in this step is to generate a netlist of library components that best fit the given constraints.
For HDL synthesis, we use tools targeting ASICs as they allow more flexibility in their input technology library.
We design a custom technology library that contains 2-input gates as required by the front-end GC tools.
We set the area of XOR gates to 0 and the area of non-XOR gates to a non-0 value.
By choosing area minimization as the only optimization goal, the synthesis tool produces netlists with the minimum possible number of non-XOR gates.

An additional feature of our custom technology library is that it contains non-standard gates (other than basic gates like NOT, AND, NAND, OR, NOR, XOR, and XNOR) to increase flexibility of mapping process.
For example, the logical functions $F = A\wedge B$ and $F = (\neg A)\wedge B$ requires equal effort in garbling/evaluation.
However by using only standard gates, the second function will require two gates (a NOT gate and an AND gate) and store one extra token for $\neg A$ in the memory.
We include four such non-standard gates with an inverted input in our custom library.

For synthesis of sequential circuits, the technology library includes memory elements.
These elements can be implemented as FFs which are connected to a clock signal.
Although in conventional ASIC design FFs are typically as costly as four AND gates, in our GC application, FFs do not have any impact on the garbling/evaluation process as they require no cryptographic operations.
Therefore, we set the area of FFs to 0 to show its lack of impact on computation and communication time of garbling/evaluation.
Moreover, we modify our FFs such that they can accept an initial value.
This helps us remove extra MUXs in standard FF design for initialization.

\section{Offline Circuit Synthesis}
In \sys{}, we use HDL synthesis tools in an offline manner to generate a circuit for a given functionality.
This offline synthesis followed by a topological sort provides a ready-to-use circuit description for any GC framework.
This approach, unlike online circuit generation, does not require misspending time for circuit generation during garbling/evaluation.
It also enables the use of beneficial synthesis optimization techniques that were previously infeasible for online generation.
Moreover, the synthesis tools have a global view of the circuit, unlike previous work that manually optimized small modules of the circuit.
This allows more effective optimization for any arbitrary function and set of constraints.

However, the offline approach has certain limitations when it comes to generating circuits for extremely large functions.
Fortunately, the sequential description helps to overcome most limitations as it generates more compact circuits.
Sequential circuits are radically smaller than combinational ones with the same functionality.
This property allows synthesis tools to perform more effective circuit optimization.
Moreover, the compatibility of our sequential descriptions with standard synthesis tools simplifies the workflow of circuit generation for SFE applications.
