% !TEX root = 0_main.tex
\chapter{Hardware Synthesis}
\section{Global Flow}
The global flow of TinyGarble is shown in \fig{fig:globalflow}.
It consists of the following four steps:

\begin{figure*}
\centering
\includegraphics[width=0.95\textwidth]{flow_chart-crop.pdf}
\caption{Global flow of TinyGarble for both combinational and sequential synthesis.
  The inputs can be either a C/C++ program (translatable to HDL via a standard HLS tool) or a direct HDL description.
  TinyGarble is able to provide circuit description for any given GC framework.}
\label{fig:globalflow}
\end{figure*}

\begin{enumerate}
\item
  The input to the TinyGarble framework is a file that describes a sequential or combinational function written in an HDL like Verilog or VHDL.
  The function can also be written in a high level language like C/C++ and automatically translated to HDL using an HLS tool.
  In the sequential circuit, the degree of folding is specified by the user.

\item
  A standard HDL synthesis tool compiles the HDL to generate a netlist file.
  The synthesis tool optimizes the netlist based on the user defined objectives/constraints and a customized library.

\item
  The netlist is parsed and topologically sorted.
  If the circuit is sequential, only its combinational part is sorted.
  Then, the sorted netlist is saved in a format compatible with any given GC framework e.g., Simple Circuit Description (SCD) compatible with JustGarble~\cite{bellare2013efficient}.

\item
  The circuit description is provided to both the garbler and evaluator to securely evaluate the function by the GC framework.
\end{enumerate}

\begin{figure*}
\centering
\includegraphics[width=\textwidth]{HLS_HDL_netlist-crop.pdf}
\caption{Sample files at the different steps of TinyGarble's flow for Hamming distance function.}
\label{fig:globalflow_sample}
\end{figure*}

\fig{fig:globalflow_sample} shows examples of files at different steps of TinyGarble's flow for the Hamming distance function.
The \textsl{hamming.c} file contains the description of the function in the C language.
The user inputs this function to a HLS tool to generate the corresponding description in Verilog.
The resulting Verilog file is functionally similar to the \textsl{hamming.v} file shown in the figure, but it may look more complicated and be less efficient as it is generated by an automated tool.
A user can also write the description directly in Verilog to have more control on the circuit and therefore a more efficient netlist.
The \textsl{hamming.v} file is provided to an HDL synthesis tool along with the TinyGarble custom libraries to generate netlist \textsl{hamming\_netlist.v}.
The netlist describes the same function as \textsl{hamming.c} and \textsl{hamming.v} but uses the logic cells provided in the technology library.
The technology library contains 2-input-1-output logic cells to be compatible with front-end garbling tools~\cite{malkhi2004fairplay, bellare2013efficient}.

\section{HDL Synthesis}
As described in \sect{subsec:preli_GC}, Yao's protocol requires the function to be represented as a Boolean circuit.
Previous work like FairPlay \cite{malkhi2004fairplay} and WYSTERIA \cite{rastogi2014wysteria} used custom-made languages to describe a function and generate the circuit for GC operations.
In our TinyGarble framework, the user may describe a function in a standard HDL like Verilog or VHDL.
She may also write the function in a high level language like C/C++ and convert it to HDL using a HLS tool.
TinyGarble uses existing HDL synthesis tools to map an HDL to a list of basic binary gates.
In digital circuit theory, this list is called a \emph{netlist}.
The netlist is generated based on various constraints and objectives such that it is functionally equivalent to the HDL/HLS input function.
Exploiting synthesis tools helps to reduce both number of non-XOR gates in the circuit and the garbling time while also making the framework easily accessible.

\section{Synthesis Flow}
In the first step, a synthesis converts functional description of a circuit into a structural representation consisting of standard logical elements.
Then, it converts this structural representation into a netlist specific to the target platform.
In both steps, the synthesis tool works under a set of user defined constraints/objectives like minimizing the total delay or limiting the area.
In the following, we describe the details of these two steps and how we manipulate the synthesis tools in each of the steps to generate optimized netlists for SFE.

\subsection{Synthesis library}
The first step in the synthesis flow is to convert arithmetic and conditional operations like add, multiply, and if-else to their logical representations that fits best to the user's constraints.
For example, the sum of two N-bit numbers can be replaced with an N-bit ripple carry adder in case of area optimization or an N-bit carry look ahead adder in case of timing optimization.
A library that consists of these various implementations is called a \emph{synthesis library}.
We develop our own synthesis library that includes implementations customized for SFE.
In this library, we build the arithmetic operations based on a full adder with one non-XOR gate \cite{boyar2006concrete} and conditional operations based on a 2-to-1 multiplexer (MUX) with one non-XOR gate \cite{kolesnikov2008improved}.

\subsection{Technology library}
The next step is to map the structural representation onto a \emph{technology library} to generate the netlist.
A technology library contains basic units available in the target platform.
For example, tools targeting Field Programmable Gate Arrays (FPGAs) like Xilinx ISE or Quartus contain Look-Up Tables and Flip Flops in their technology libraries, which form the architecture of an FPGA.
On the other hand, tools targeting Application Specific Integrated Circuits (ASICs) like Synopsys DC, Cadence, and ABC, may contain a more diverse collection of elements starting from basic gates like AND, OR, etc., to more complex units like FFs.
The technology library contains logical descriptions of these units along with performance parameters like their delay and area.
The goal of the synthesis tool in this step is to generate a netlist of library components that best fit the given constraints.
For HDL synthesis, we use tools targeting ASICs as they allow more flexibility in their input technology library.
We design a custom technology library that contains 2-input gates as required by the front-end GC tools.
We set the area of XOR gates to 0 and the area of non-XOR gates to a non-0 value.
By choosing area minimization as the only optimization goal, the synthesis tool produces netlists with the minimum possible number of non-XOR gates.

An additional feature of our custom technology library is that it contains non-standard gates (other than basic gates like NOT, AND, NAND, OR, NOR, XOR, and XNOR) to increase flexibility of mapping process.
For example, the logical functions $F = A\wedge B$ and $F = (\neg A)\wedge B$ requires equal effort in garbling/evaluation.
However by using only standard gates, the second function will require two gates (a NOT gate and an AND gate) and store one extra token for $\neg A$ in the memory.
We include four such non-standard gates with an inverted input in our custom library.

For synthesis of sequential circuits, the technology library includes memory elements.
These elements can be implemented as FFs which are connected to a clock signal.
Although in conventional ASIC design FFs are typically as costly as four AND gates, in our GC application, FFs do not have any impact on the garbling/evaluation process as they require no cryptographic operations.
Therefore, we set the area of FFs to 0 to show its lack of impact on computation and communication time of garbling/evaluation.
Moreover, we modify our FFs such that they can accept an initial value.
This helps us remove extra MUXs in standard FF design for initialization.

\section{Offline Circuit Synthesis}
In TinyGarble, we use HDL synthesis tools in an offline manner to generate a circuit for a given functionality.
This offline synthesis followed by a topological sort provides a ready-to-use circuit description for any GC framework.
This approach, unlike online circuit generation, does not require misspending time for circuit generation during garbling/evaluation.
It also enables the use of beneficial synthesis optimization techniques that were previously infeasible for online generation.
Moreover, the synthesis tools have a global view of the circuit, unlike previous work that manually optimized small modules of the circuit.
This allows more effective optimization for any arbitrary function and set of constraints.

However, the offline approach has certain limitations when it comes to generating circuits for extremely large functions.
Fortunately, the sequential description helps to overcome most limitations as it generates more compact circuits.
Sequential circuits are radically smaller than combinational ones with the same functionality.
This property allows synthesis tools to perform more effective circuit optimization.
Moreover, the compatibility of our sequential descriptions with standard synthesis tools simplifies the workflow of circuit generation for SFE applications.

\section{Limitation}


\section{Evaluation}
