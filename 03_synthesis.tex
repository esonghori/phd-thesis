% !TEX root = 0_main.tex
\chapter{Hardware Synthesis for GC}
In this chapter, first we review the background of the HDL synthesis for digital circuits.
Next, we explain our approach for generating optimized combinational circuit for the GC protocol using HDL synthesis.
Finally we discuss the limitation of HDL synthesis techniques and tools for generating large combinational circuits.

\section{Background on HDL Synthesis}
HDL synthesis refers to the process of translating an abstract form of  function (circuit) presentation to the gate-level logic implementation using a series of sophisticated optimizations, transformations, and mapping \cite{sentovich1992sis,micheli1994synthesis,devadas1994logic,brayton1987mis}.
An HDL synthesis tool is a computer program which typically accepts the input circuit in some algorithmic form, logic equation, or even a table, and outputs an implementation suitable for the target hardware platform.
Classic commercial/open-source HDL synthesis tools accept the input functions in the HDL format, e.g., Verilog or VHDL~\cite{tool:DesignCompiler,tool:ABC,tool:Encounter,tool:HDLdesigner,tool:PandA,decaluwe2004myhdl} but newer ones also accept high level format, e.g., C/C++~\cite{Gupta2004, tool:Vivado}.
The common target hardware platforms for the synthesized logic include Field Programmable Gate Arrays (FPGA), Programmable Array Logic (PAL), and Application-Specific Integrated Circuits (ASIC).

The input functions (circuits), regardless of their HDL or higher level format, can be defined by the implementer to be purely combinational logic that is fully representable by Boolean functions, or they might be sequential logic which is a more general format.

Typical practical implementations of a logic function utilize a multi-level network of logic elements.
The tools translate the input to the implementation in two steps: (i) Logic minimization; and (ii) logic optimization.
Logic minimization simplifies the function by combining the separate terms into larger ones containing fewer variables.
The best known algorithm for logic minimization is the ESPRESSO algorithm~\cite{brayton1984logic}; although the resulting minimization is not guaranteed to be the global minimum, it provides a very close approximation of the optimal, while the solution is always free from redundancy.
This algorithm has been incorporated as a standard logic function minimization step in virtually any contemporary HDL synthesis tool.

Logic optimization takes this minimized format, further processes it, and eventually maps it onto the available basic logic cells or library elements in the target technology (e.g., Look up tables in FPGA and basic Boolean gates in ASIC).

Mapping is limited by factors such as the available gates (logic functions or standard cells) in the technology library, as well as the drive sizes, delay, power, and area characteristics of each gate.

Newer generations of synthesis programs, referred to as high level synthesis (HLS) tools, accept other forms of input in a higher level programming language \cite{Chapter:Zhang2008,chu1989hyper,corazao1996performance}, e.g., ANSI C, C++, SystemC, or Python.
HLS tools are also available in both open-source and commercial forms, for example see \cite{tool:Vivado,decaluwe2004myhdl,tool:PandA}.
The limitation of the higher level languages is that the behavior of the function is typically decoupled from the timing.
The HLS tools handle the micro-architecture and transform the untimed or partially timed functional code into a fully timed HDL implementation, which in turn can be compiled by a classic synthesis tool.
It is well-known that the performance of the circuits resulting from automatically compiled HLS code into HDL is inferior to the performance of functions directly written in HDL.
Therefore, the main driver for the development of HLS tools is user-friendliness and not performance.

\section{TinyGarble HDL Synthesis}
As explained in \sect{sec:prelim_gc}, Yao's GC protocol requires the underlying function to be represented as a Boolean circuit.
Previous work like FairPlay \cite{malkhi2004fairplay} and WYSTERIA \cite{rastogi2014wysteria} used custom-made languages to describe a function and generate the circuit for GC computation.
In TinyGarble framework, the user may describe a function in a standard HDL like Verilog or VHDL.
(She may also write the function in a high level language like C/C++ and convert it to HDL using a HLS tool.)
TinyGarble uses existing HDL synthesis tools to map an HDL to a list of basic binary gates.
In digital circuit theory, this list is called a \emph{netlist}.
The netlist is generated based on various constraints and objectives such that it is functionally equivalent to the HDL/HLS input function.
Exploiting synthesis tools helps to reduce number of AND gates in the circuit and and as a result the total garbling time and communication while also making the framework easily accessible.

\section{Synthesis Flow}
In the first step, a synthesis tool converts functional description of a circuit into a structural representation consisting of standard logical elements.
Then, it converts this structural representation into a netlist specific to the target platform.
In both steps, the synthesis tool works under a set of user defined constraints/objectives like minimizing the total delay or limiting the area.
In the following, we describe the details of these two steps and how we manipulate the synthesis tools in each of the steps to generate optimized netlists for the GC protocol.

\subsection{Synthesis library}
The first step in the synthesis flow is to convert arithmetic and conditional operations like add, multiply, and if-else to their logical representations that fits best to the user's constraints.
For example, the sum of two N-bit numbers can be replaced with an N-bit ripple carry adder in case of area optimization or an N-bit carry look ahead adder in case of timing optimization.
A library that consists of these various implementations is called a \emph{synthesis library}.
We develop our own synthesis library that includes implementations customized for the GC protocl.
In this library, we build the arithmetic operations based on a full adder with one AND gate \cite{boyar2006concrete} and conditional operations based on a 2-to-1 multiplexer (MUX) with one AND gate \cite{kolesnikov2008improved}.

\subsection{Technology library}\label{sec:syn_tech}
The next step is to map the structural representation onto a \emph{technology library} to generate the netlist.
A technology library contains basic units available in the target platform.
For example, tools targeting Field Programmable Gate Arrays (FPGAs) like Xilinx ISE or Quartus contain Look-Up Tables and Flip Flops in their technology libraries, which form the architecture of an FPGA.
On the other hand, tools targeting Application Specific Integrated Circuits (ASICs) like Synopsys DC, Cadence, and ABC, may contain a more diverse collection of elements starting from basic gates like AND, OR, etc., to more complex units like FFs.
The technology library contains logical descriptions of these units along with performance parameters like their delay and area.
The goal of the synthesis tool in this step is to generate a netlist of library components that best fit the given constraints.
For HDL synthesis, we use tools targeting ASICs as they allow more flexibility in their input technology library.
We design a custom technology library that contains 2-input gates as they incur minimum garbled tables in the GC protocol compared to gates with more inputs.
We set the area of XOR gates to 0 and the area of AND gates to a non-0 value, e.g., 1.
By choosing area minimization as the only optimization goal, the synthesis tool produces a netlist with the minimum possible number of AND gates.
This reduces the total computation and communication of the GC protocol due to the Free-XOR optimization~\cite{kolesnikov2008improved}.

An additional feature of our custom technology library is that it contains non-standard gates (other than basic gates like NOT, AND, NAND, OR, NOR, XOR, and XNOR) to increase flexibility of mapping process.
For example, the logical functions $F = A\wedge B$ and $F = (\neg A)\wedge B$ requires equal effort in garbling/evaluation.
However by using only standard gates, the second function will require two gates (a NOT gate and an AND gate) and store one extra pair of keys for $\neg A$ in the memory.
We include four such non-standard gates with an inverted input in our custom library.
XOR, XNOR, and NOT gates are free so their area is set to 0.
The area of the rest of gates, similar to the area of AND, is set 1.
In order to be consist with the previous work in the literature, we use ``number of AND gates'' to refer to the number of non-free gates in a circuit throughout this thesis.
Due to the Free-XOR optimization, this metric directly corresponds to time and communication cost of garbling/evaluating the circuit.

\section{Offline Circuit Synthesis}
In TinyGarble GC synthesis, we use HDL synthesis tools in an offline manner to generate a circuit for a given functionality.
This offline synthesis followed by a topological sort provides a ready-to-use circuit description for any GC implementations including our TinyGarble GC engine.
This approach, unlike online circuit generation, does not require misspending time for circuit generation during garbling/evaluation.
It also enables the use of beneficial synthesis optimization techniques that were previously infeasible for online generation.
Moreover, the synthesis tools have a global view of the circuit, unlike previous work that manually optimized small modules of the circuit.
This allows more effective optimization for any arbitrary function and set of constraints.

\section{Limitation}\label{sec:syn_limit}
The synthesis approach has certain limitations when it comes to generating combinational circuits for extremely large functions.
Generating and optimizing large combinational circuits using synthesis tools take a lot of timing and memory resources.
These tools are not designed to support large scale combination description.
This means hardware synthesis for garbled circuit cannot be scaled, at least automatically, for large functions using the current setting.
In hardware design, the function has to be folded and described in a sequential format in order to scale circuit to cover more complex functions.
In the next chapter, we will discuss possibility of using sequential circuit for the GC protocol.
