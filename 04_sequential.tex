% !TEX root = 0_main.tex
\chapter{Sequential Garbled Circuits}\label{chap:seq}
Sequential circuits can be used as a very compact Boolean circuit description. We use sequential description to overcome the scalability limitation of the synthesis approach for combinational circuits.
In the following chapter, we first describe the concept of sequential circuits using an example.
Next, we discuss synthesizing sequential circuit for the GC protocol.
Then, we explain the modifications required to garble/evaluate sequential circuits.

\section{Sequential Circuits}
In the context of the GC protocol, we can defined sequential circuit as a folded version of combinational circuit that needs to be evaluated multiple cycle.
Unlike combinational circuits where the output depends only on the inputs, the output of sequential circuit depends on both input and the state of the circuit stored in its memory.
Usually, intermediate values during computation is stored as a state of the circuit and is used in later cycles to complete computation of the function.
In following, we illustrate the difference between combination and sequential circuit using a simple 4-bit adder as a function.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{adder-crop.pdf}
    \caption{Combinational and sequential design of a 4-bit Adder.
  (a) HA circuit.
  (b) FA circuit.
  (c) Combinational 4-bit Adder using 1 HA and 3 FAs.
  (d) Sequential 4-bit Adder using one FA.}\label{fig:combSeq}
\end{figure}

\fig{fig:combSeq} demonstrates an example of a combinational and a sequential implementation for a 4-bit Adder function with inputs $x = \overline{x_3x_2x_1x_0}$ and $y = \overline{y_3y_2y_1y_0}$, producing sum $s  = \overline{s_3s_2s_1s_0} = f(x, y) = x + y$.
\fig{fig:combSeq}a and \ref{fig:combSeq}b show the internal combinational circuit of a half Adder (HA) and a full Adder (FA) respectively.
In \fig{fig:combSeq}c a combinational Adder is built by cascading 3 FAs and one HA.
\fig{fig:combSeq}d represents a sequential implementation of a 4-bit Adder which uses one FA and a one bit FF to save the carry bit from the previous cycle.
The circuit should be evaluated for 4 cycles.
At the first cycle the carry bit is $z_0=0$.
Note that, in the combinational circuit we use three FAs and one HA whereas in the sequential circuit, we have to use one FA for 4 sequential cycles.
This asymmetry in the loop of Addition function introduces a small \emph{overhead} in GC computation and communication time as an HA circuit has fewer gates compared to a FA circuit.

However, the total number of gates for representing the function is reduced approximately by a factor of 4 when using a sequential circuit (one FA for sequential compared with three FA and one HA for combinational).
This helps to limit the memory footprint for garbling and evaluation required for storing circuit description and wire keys ($k$-bit per wire, see \sect{subsect:preli_GC}).
In a sequential circuit, the number of labels that need to be stored in memory at any moment is proportional to the number of gates in the circuit.
The wire labels are simply over-written at each sequential cycle.
Only labels corresponding to FFs are kept for the next cycle.

Nearly all commercial circuits used in digital hardware are designed in sequential format.
There are multiple reasons for preferring sequential circuit description over combinational including the reduction in complexity, area, power, and cost, as well as natural mapping of finite state machine control functions into a sequential format.
Some of these reasons also provide a rationale for sequential description of a function in GC, including: (i) reduction in size and memory footprint that is achieved by introducing the state elements and feedback loop from output to input; (ii) removing the need to perform costly compile-time/runtime loop unrolling by embracing loops within the sequential feedback loop; (iii) providing a new degree of freedom for folding by the placement of memory elements in the long combinational paths--the placement can be done in accordance with the user's objective; (iv) solving the limitation of synthesis techniques and tools for large function (see /sec{sect:syn-limit}) by describing circuits in compact sequential format.

\begin{figure}[ht]
    \centering
	\includegraphics[width=0.8\textwidth]{sequential-open-crop.pdf}
	\caption{Functionally equivalent unrolled sequential circuit corresponding to \fig{fig:sequential}.}
	\label{fig:open-sequential}
\end{figure}

During the evaluation of a sequential circuit, the combinational block is evaluated $c$ times where $c$ is the number of sequential cycles that the circuit operates.
We can visualize this process as the unrolled combinational representation of the sequential circuit as shown in \fig{fig:open-sequential}.
$c$ also shows the folding factor of the sequential circuit ($c=1$ means the circuit is combinational).
The inputs/outputs of the unrolled circuit are the inputs/outputs of the combinational block in all the cycles.
The present states at each cycle $\textrm{cid}$, where $0 \le \textrm{cid} < c$, are equal to the next states at the previous cycle ($\textrm{cid}-1$).
The present states at $\textrm{cid}=0$ are equal to the input initial value.

FF acts as a wire between recurring combinational circuits.

During generation and evaluation of the garbled circuit, it must be ensured that the encryption tweaks $T$ (see \sect{subsect:preli_GC}) for each gate is unique because otherwise security is broken \cite[Sect. 3.4]{henecka2013faster}.
In TinyGarble GC engine, to ensure the uniqueness property, we set tweak $T$ for each gate to be the concatenation of the cycle index (cid) and the unique gate identifiers (gid) in the combinational part of the sequential circuit, i.e., $T = \textrm{cid} || \textrm{gid}$.
An alternative method would be to use a monotonic counter in the circuit generation/evaluation routines which is increased by one for each gate.
As in previous work, security and correctness of the GC garbling/evaluation follow from the uniqueness of the tweak $T$ and the existing proofs of security and correctness, see \cite{lindell2009proof, bellare2013efficient}.

\section{Synthesis Sequential Circuit}
Fortunately, extending TinyGarble GC synthesis to support sequential circuits is straightforward since the synthesis tools are designed to work them in the first place.
We add memory element of sequential circuits into the technology library of TinyGarble (described in \sect{sect:syn-tech}).
These elements can be implemented as FFs which are connected to a clock signal.
Although in conventional ASIC design FFs are typically as costly as four AND gates, as seen above in our GC application, FFs do not have any impact on the garbling/evaluation process as they require no cryptographic operations.
Therefore, we set the area of FFs to 0 to show its lack of impact on computation and communication time of garbling/evaluation.
Moreover, we modify our FFs such that they can accept an initial value.
This helps us remove extra MUXs in standard FF design for initialization.

Describing functions using sequential circuits helps to overcome the scalability limitations of synthesis tool.
Sequential circuits are radically smaller than combinational ones with the same functionality.
This property allows synthesis tools to not only generates the circuit with less recourses, but to find a more optimized circuit.
Moreover, the compatibility of our sequential descriptions with standard synthesis tools simplifies the workflow of circuit generation for SFE applications.

\section{Overhead of Sequential Circuit}

sequential circuit folds the function into a single loop.
The computation in many functions are not perfectly symmetric.
Thus these function when are described in seqeuntial circuits incure an overhead similar to the one explained earlier in the example of \fig{fig:combSeq}.
In the following, we explain the source of the overhead using a more general example.

\begin{figure}[ht]
    \centering
    \begin{subfigure}[t]{0.8\textwidth}
        \includegraphics[width=\textwidth]{seq-overhead-comb-crop.pdf}
        \caption{Combination Circuit.}\label{fig:seq-overhead-comb}
    \end{subfigure}
    \begin{subfigure}[t]{0.7\textwidth}
        \includegraphics[width=\textwidth]{seq-overhead-seq-crop.pdf}
        \caption{Sequential Circuit.}\label{fig:seq-overhead-seq}
    \end{subfigure}\\
    \caption{The combinational and sequential representations of a function with an asymmetric loop.
    The sequential implementation has to be evaluated for 6 cycles and eventually needs more gates to be garbled/evaluated compared to the combinational one.}\label{fig:fig:seq-overhead-comb}
\end{figure}

\fig{fig:seq-overhead-comb} shows a function that is represented as a combinational circuit.
The computation in the function can be divided into 6 steps.
The computation in the first and last steps are different from the rest.
U1 sub-circuit represents the computation in the first step, u2 the middle four, and U3 the last step.

This combinational circuit can be rearrange as a more compact sequential circuit such that each step is computed in one cycle of the sequential circuit, see \fig{fig:seq-overhead-seq}).
It can be done using a MUX to select from the output of the sub-circuits according to the cycle id (cid).
If cid is 0, U1 is selected, if it is 5, U3 is selected, otherwise U2 is selected.
At each cycle, the output of the selected sub-circuit is stored in the FF to be used in the next cycles.
It means that the unselected sub-circuits remain idle in that cycle.

The number of AND gates that has to garbled/evaluated in the combinational circuit is $C_{U1}+4*C_{U2}+C_{U3}$, where $C_{Ui}$ is the number of AND gates in Ui sub-circuit.
Since the sequential circuit has to be garbled/evaluated for 6 times, the total gates for sequential circuit is $6*(C_{U1}+C_{U2}+C_{U3}+C_{MUX})$, where $C_{MUX}$ is number of AND in the MUX.
Thus the overhead of the seqeuntial circuit is $5*C_{U1}+2*C_{U1}+5*C_{U3}+6*C_{MUX})$.

The source of the overhead is (i) the idle sub-circuits (ii) the newly introduced MUX in the sequential circuit.
In the next chapter, we will discuss how to remove this overhead using an algorithm to skip unnecessary garbling/evaluation.
