% !TEX root = 0_main.tex
\chapter{Related Work}\label{chap:related}
We classify related work into compilers for GCs (\sect{sect:GCCompiler}), libraries for GCs (\sect{sect:GCLibs}), GC implementations with hardware accelerators (\sect{sect:HWaccel}), and GC implementations on mobile devices (\sect{sect:mobile}).

\section{Compiler for Garbled Circuits}\label{sec:GCCompiler}
The following tools compile high level function descriptions into a Boolean circuit which can be used in GC.
The first realization of GCs was Fairplay \cite{malkhi2004fairplay} which provides a custom high level procedural language called SFDL (Secure Function Definition Language) that is compiled into a circuit description language, SHDL (Secure Hardware Description Language).
Another compiler is TASTY \cite{HKSSW10} which allows to combine garbled circuits and homomorphic encryption.
The compiler of \cite{kreuter2012billion} for the first time showed scalability to circuits consisting of billions of gates, e.g., a 4095x4095-bit edit distance circuit with almost 6 Billion gates.
The compiler of \cite{franz2014cbmc} allows to use a subset of ANSI C as input language.

To reduce the memory overhead for storing large circuits and hence increase scalability, PCF \cite{kreuter2013pcf} introduced loops that, if given manually in the high level language, are kept until the GC evaluation.
In contrast to PCF, \sys{} allows to infer loops automatically and also allows to optimize across multiple sub-circuits.

\section{Libraries for Garbled Circuits}\label{sec:GCLibs}
Instead of compiling circuits, FastGC \cite{huang2011faster} proposed to use a library-based approach where circuits can be programmed and easily integrated into high-level applications.
Another GC library is VMCRYPT \cite{malka2011vmcrypt} that allows to dynamically construct and deconstruct sub-circuits.
FastGC was extended in \cite{HS13} to re-use the same sub-circuits.
Another library for secure computation is ABY that allows the efficient combination of multiple secure computation approaches \cite{DSZ15}.

In all these library-based approaches the circuits and their decomposition into sub-circuits has to be specified manually by the programmer, whereas we provide an automated approach.

\section{GC Implementations with Hardware Accelerators}\label{sec:HWaccel}
The following works provide better performance by implementing garbled circuits in hardware, on GPUs, or using AES-NI available in recent CPUs.
These works can benefit from the compact representation generated by \sys.

J\"arvinen et al., \cite{jarvinen2010garbled} proposed a generic hardware architecture for GC.
They realized two FPGA-based prototypes: a system-on-a-programmable-chip with access to a hardware crypto accelerator targeting smartcards and smartphones, and a stand-alone hardware implementation targeting ASICs.

Recently, several accelerations of GCs using GPUs have been proposed.
Husted et al., implemented Yao's GC by using optimizations such as Free XOR, pipelining, and OT extension \cite{husted2013gpu}.
Pu et al., realized dynamic programming based on GC to solve the Edit-Distance (ED) and the Smith-Waterman (SW) problems \cite{pu2013computing}.
They also used the same optimizations as \cite{husted2013gpu} along with permute-and-encrypt, efficient lookup-table design, and compact circuits \cite{pu2013computing}.
Frederiksen et al., implemented a secure computation protocol with security against malicious adversaries based on cut-and-choose of Yao's garbled circuit and an efficient OT extension for two-party computation on GPUs \cite{frederiksen2013fast}.

Bellare et al., propose JustGarble in which they use fixed-key AES for circuit-garbling \cite{bellare2013efficient}.
They show their implementation using AES-NI can efficiently garble and execute a circuit far faster than any prior report.

\section{GC Implementations on Mobile Devices}\label{sec:mobile}
Our approach for generating compact circuit representations is also beneficial when performing secure computation on resource constrained devices such as mobile devices which have a limited amount of main memory.
Secure computation on mobile devices using garbled circuits was proposed in \cite{HCE11}.
Also the protocol described in \cite{DSZ14}, which uses a smartcard installed in the mobile device, can benefit from our more compact circuit representation.
In \cite{CMTB13, CLT14} the mobiles no longer need to process circuits any more as GC generation and evaluation is outsourced to cloud servers.
